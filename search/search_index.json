{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Iridescence a light-weight visualization library for rapid prototyping of 3D algorithms. This library is designed for accelerating personal research and development projects (mainly focusing on point-cloud-related algorithms) and is NOT intended to be a general-purpose visualization library with rich rendering capabilities.</p> <p> on Ubuntu 18.04 / 20.04 / 22.04</p>"},{"location":"#features","title":"Features","text":"<p>What this library provides:</p> <ul> <li>An easy-to-use 3D visualization framework (inpaticular suitable for rendering point clouds)</li> <li>Tightly integrated Dear ImGui interfaces for rapid UI design</li> </ul> <p>What this library does NOT provide:</p> <ul> <li>Realistic rendering and shading</li> <li>Rich textured 3D mesh rendering</li> </ul>"},{"location":"#dependencies","title":"Dependencies","text":"<ul> <li>GLFW (zlib/libpng license)</li> <li>gl3w (Public domain)</li> <li>Dear ImGui (MIT license)</li> <li>ImGuizmo (MIT license)</li> <li>implot (MIT license)</li> <li>Eigen (MPL2 license)</li> <li>portable-file-dialogs (WTFPL license)</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#install-from-source","title":"Install from source","text":"<pre><code># Install dependencies\nsudo apt-get install -y libglm-dev libglfw3-dev libpng-dev libjpeg-dev libeigen3-dev\n\n# Build and install Iridescence\ngit clone https://github.com/koide3/iridescence\nmkdir iridescence/build &amp;&amp; cd iridescence/build\ncmake ..\nmake -j\nsudo make install\n\n# [Optional] Build and install python bindings\ncd ..\npip install .\n\n# [Optional2] Install stubs for autocomplete\npip install pybind11-stubgen\ncd ~/.local/lib/python3.10/site-packages\npybind11-stubgen -o . --ignore-invalid=all pyridescence\n</code></pre>"},{"location":"#install-from-ppa-amd64-arm64","title":"Install from PPA [AMD64, ARM64]","text":""},{"location":"#ubuntu-2404","title":"Ubuntu 24.04","text":"<pre><code>curl -s --compressed \"https://koide3.github.io/ppa/ubuntu2404/KEY.gpg\" | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/koide3_ppa.gpg &gt;/dev/null\necho \"deb [signed-by=/etc/apt/trusted.gpg.d/koide3_ppa.gpg] https://koide3.github.io/ppa/ubuntu2404 ./\" | sudo tee /etc/apt/sources.list.d/koide3_ppa.list\n\nsudo apt update &amp;&amp; sudo apt install -y libiridescence-dev\n</code></pre>"},{"location":"#ubuntu-2204","title":"Ubuntu 22.04","text":"<pre><code>curl -s --compressed \"https://koide3.github.io/ppa/ubuntu2204/KEY.gpg\" | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/koide3_ppa.gpg &gt;/dev/null\necho \"deb [signed-by=/etc/apt/trusted.gpg.d/koide3_ppa.gpg] https://koide3.github.io/ppa/ubuntu2204 ./\" | sudo tee /etc/apt/sources.list.d/koide3_ppa.list\n\nsudo apt update &amp;&amp; sudo apt install -y libiridescence-dev\n</code></pre>"},{"location":"#ubuntu-2004","title":"Ubuntu 20.04","text":"<pre><code>curl -s --compressed \"https://koide3.github.io/ppa/ubuntu2004/KEY.gpg\" | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/koide3_ppa.gpg &gt;/dev/null\necho \"deb [signed-by=/etc/apt/trusted.gpg.d/koide3_ppa.gpg] https://koide3.github.io/ppa/ubuntu2004 ./\" | sudo tee /etc/apt/sources.list.d/koide3_ppa.list\n\nsudo apt update &amp;&amp; sudo apt install -y libiridescence-dev\n</code></pre>"},{"location":"#use-iridescence-in-your-cmake-project","title":"Use Iridescence in your cmake project","text":"<pre><code># Find package\nfind_package(Iridescence REQUIRED)\n# Add include dirs and link libraries\nadd_executable(your_program\nsrc/your_program.cpp\n)\ntarget_link_libraries(your_program\nIridescence::Iridescence\n)\n</code></pre>"},{"location":"#minimum-example","title":"Minimum example","text":"<p>C++: <pre><code>#include &lt;glk/primitives/primitives.hpp&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\nint main(int argc, char** argv) {\n// Create a viewer instance (global singleton)\nauto viewer = guik::LightViewer::instance();\nfloat angle = 0.0f;\n// Register a callback for UI rendering\nviewer-&gt;register_ui_callback(\"ui\", [&amp;]() {\n// In the callback, you can call ImGui commands to create your UI.\n// Here, we use \"DragFloat\" and \"Button\" to create a simple UI.\nImGui::DragFloat(\"Angle\", &amp;angle, 0.01f);\nif (ImGui::Button(\"Close\")) {\nviewer-&gt;close();\n}\n});\n// Spin the viewer until it gets closed\nwhile (viewer-&gt;spin_once()) {\n// Objects to be rendered are called \"drawables\" and managed with unique names.\n// Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes.\n// The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default.\nEigen::AngleAxisf transform(angle, Eigen::Vector3f::UnitZ());\nviewer-&gt;update_drawable(\"sphere\", glk::Primitives::sphere(), guik::Rainbow(transform));\nviewer-&gt;update_drawable(\"wire_sphere\", glk::Primitives::wire_sphere(), guik::FlatColor({0.1f, 0.7f, 1.0f, 1.0f}, transform));\n}\nreturn 0;\n}\n</code></pre></p> Python version <pre><code>#!/usr/bin/python3\nimport numpy\nfrom scipy.spatial.transform import Rotation\nfrom pyridescence import *\n# Create a viewer instance (global singleton)\nviewer = guik.LightViewer.instance()\nangle = 0.0\n# Define a callback for UI rendering\ndef ui_callback():\n# In the callback, you can call ImGui commands to create your UI.\n# Here, we use \"DragFloat\" and \"Button\" to create a simple UI.\nglobal angle\n_, angle = imgui.drag_float('angle', angle, 0.01)\nif imgui.button('close'):\nviewer.close()\n# Register a callback for UI rendering\nviewer.register_ui_callback('ui', ui_callback)\n# Spin the viewer until it gets closed\nwhile viewer.spin_once():\n# Objects to be rendered are called \"drawables\" and managed with unique names.\n# Here, solid and wire spheres are registered to the viewer respectively with the \"Rainbow\" and \"FlatColor\" coloring schemes.\n# The \"Rainbow\" coloring scheme encodes the height of each fragment using the turbo colormap by default.\ntransform = numpy.identity(4)\ntransform[:3, :3] = Rotation.from_rotvec([0.0, 0.0, angle]).as_matrix()\nviewer.update_drawable('sphere', glk.primitives.sphere(), guik.Rainbow(transform))\nviewer.update_drawable('wire_sphere', glk.primitives.wire_sphere(), guik.FlatColor(0.1, 0.7, 1.0, 1.0, transform))\n</code></pre> <p></p>"},{"location":"#some-use-examples-in-my-academic-works","title":"Some use examples in my academic works","text":""},{"location":"#license","title":"License","text":"<p>This package is released under the MIT license.</p>"},{"location":"basic/","title":"Basic usage","text":""},{"location":"basic/#creating-a-viewer-instance","title":"Creating a viewer instance","text":"<p><code>guik::LightViewer::instance()</code> creates and returns a global viewer instance. The viewer instance is created on the first call, and results of <code>guik::LightViewer::instance()</code> refer to the same globally singular instance (i.e., singleton pattern).</p> <p><code>viewer-&gt;spin_once()</code> updates viewer contents and renders a frame on the window. It returns <code>false</code> when the viewer window is closed.</p> <p>The following code is a minimum example to show a blank viewer window.</p> <pre><code>#include &lt;guik/viewer/light_viewer.hpp&gt;\nint main(int argc, char** argv) {\n// Create a global viewer instance\nauto viewer = guik::LightViewer::instance();\n// Spin the viewer until the window gets closed\nwhile (viewer-&gt;spin_once()) {}\n}\n</code></pre> <p></p> <p>Instead of calling <code>spin_once()</code> in a while loop, you can also use <code>spin()</code> that spins the viewer until the windows gets closed.</p> <pre><code>viewer-&gt;spin();\n// The above is equivalent to the below\nwhile(viewer-&gt;spin_once()) {}\n</code></pre> <p>There is also a shorthand function <code>guik::viewer()</code> that is equivalent to <code>guik::LightViewer::instance()</code>.</p> <pre><code>auto viewer =  guik::viewer();  // Equivalent to guik::LightViewer::instance()\n</code></pre> <p>With these convenient functions, the minimum example can be rewritten in a shorter form.</p> <pre><code>#include &lt;guik/viewer/light_viewer.hpp&gt;\nint main(int argc, char** argv) {\nauto viewer = guik::viewer();\nviewer-&gt;spin();\n}\n</code></pre>"},{"location":"basic/#registering-drawables-to-the-viewer","title":"Registering drawables to the viewer","text":"<p>3D objects to be drawn are called drawables and managed with unique names (or IDs). The following code shows a minimum example to register a wire sphere to the viewer.</p> <pre><code>#include &lt;glk/primitives/primitives.hpp&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\nint main(int argc, char** argv) {\nauto viewer = guik::viewer();\n// Register a wire sphere drawable with the name \"sphere\"\n// and the flat red coloring setting.\nviewer-&gt;update_drawable(\n\"sphere\",\nglk::Primitives::wire_sphere(),\nguik::FlatRed()\n);\nviewer-&gt;spin();\n}\n</code></pre> <p></p> <p>The first argument of <code>update_drawable()</code> is a name to be assigned to the drawable. If the name already exists, the viewer overwrites the existing drawable with the new one.</p> <p>The second argument is a drawable to be registered. Take a look at Drawables to see supported 3D drawable types.</p> <p>The third argument is a shader setting to hold rendering parameters. By changing shader setting parameters, you can control the color, pose, and shape of drawables as shown in below: <pre><code>auto transformation1 = Eigen::Translation3f(0.0f, -2.0f, 0.0f);\nauto setting1 = guik::Rainbow(transformation1);\nviewer-&gt;update_drawable(\"sphere1\", glk::Primitives::wire_sphere(), setting1);\nauto transformation2 = Eigen::Translation3f(0.0f, 2.0f, 0.0f);\nauto setting2 = guik::FlatColor({1.0f, 0.5f, 0.2f, 1.0f}, transformation2);\nviewer-&gt;update_drawable(\"sphere2\", glk::Primitives::wire_sphere(), setting2);\n</code></pre></p> <p></p> <p>See Shader setting for more details.</p> <p>Tip</p> <p>There are shorthand functions (e.g., <code>update_sphere</code>) for frequently used drawable types that allow registering drawables without including additional headers.</p> <pre><code>// Register a solid sphere\nviewer-&gt;update_sphere(\"sphere\", guik::FlatRed());\n</code></pre> <p>Tip</p> <p>ShaderSetting class has several utility methods for handy manipulation of the model matrix.</p> <pre><code>// Register a solid sphere with translation and scaling\nviewer-&gt;update_sphere(\"sphere\", guik::FlatRed()).translate({1.0, 2.0, 3.0}).scale(0.1);\n</code></pre>"},{"location":"basic/#registering-ui-callbacks-dear-imgui","title":"Registering UI callbacks (Dear ImGui)","text":"<p>Research and development often involve trial-and-error processes with many parameter settings that often take a large amount of effort. To accelerate such development processes, Iridescence provides tightly integrated interfaces to Dear ImGui, an immediate mode GUI library that enables designing interactive user interfaces easily and rapidly.</p> <p>To create a ImGui-based GUI, register a callback function for UI rendering events using <code>register_ui_callback()</code> . In the following example, we create a simple GUI with <code>DragFloat</code> to rotate a sphere, and <code>Button</code> to close the viewer window.</p> <pre><code>#include &lt;glk/primitives/primitives.hpp&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\nint main(int argc, char** argv) {\nauto viewer = guik::viewer();\nfloat angle = 0.0f;\n// Register a callback for UI rendering with the name \"ui_callback\".\nviewer-&gt;register_ui_callback(\"ui_callback\", [&amp;]() {\n// In the callback, you can call ImGui commands to create your UI.\nImGui::DragFloat(\"Angle\", &amp;angle, 0.01f);\nif (ImGui::Button(\"Close\")) {\nviewer-&gt;close();\n}\n});\nwhile (viewer-&gt;spin_once()) {\n// Show rotated solid and wire spheres.\nviewer-&gt;update_drawable(\"sphere\", glk::Primitives::sphere(),\nguik::Rainbow().rotate(angle, {0.0f, 0.0f, 1.0f}));\nviewer-&gt;update_drawable(\"wire_sphere\", glk::Primitives::wire_sphere(),\nguik::FlatColor(0.1f, 0.7f, 1.0f, 1.0f).rotate(angle, {0.0f, 0.0f, 1.0f}));\n}\nreturn 0;\n}\n</code></pre> <p></p> <p>See Dear ImGui for details of the GUI library.</p> <p>Note</p> <p>In addition to Dear ImGui, several libraries (implot, ImGuizmo, and portable-file-dialogs) are bundled for rapid prototyping.</p>"},{"location":"controls/","title":"Camera and model controls","text":""},{"location":"controls/#camera-control","title":"Camera control","text":"<pre><code>auto viewer = guik::LightViewer::instance();\n// Use a camera control that moves along with the XY-plane\nviewer-&gt;use_orbit_camera_control();\n// Use a camera control that moves along with the XZ-plane\nviewer-&gt;use_orbit_camera_control_xz();\n// Use a top-down camera control facing to the XY-plane\nviewer-&gt;use_topdown_camera_control();\n// Use an arcball-like camera control that can make an arbitrary pose\nviewer-&gt;use_arcball_camera_control();\n// Use an FPS-like camera control with keyboard (WASD) control\nviewer-&gt;use_fps_camera_control();\n</code></pre> <p>A useful method to let the camera keep focusing on a moving object is <code>lookat()</code> that moves the camera such that the specified position comes to the center of the camera view.</p> <pre><code>Eigen::Vector3f center_pos = ...;\nviewer-&gt;lookat(center_pos);\n</code></pre> <p><code>lookat</code> example (0:13 ~)</p>"},{"location":"controls/#keyboard-control","title":"Keyboard control","text":"Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding)"},{"location":"controls/#fps-camera-control","title":"FPS-camera control","text":"Key Description W / A / S / D Forward / Left / Backward / Right R / F Up / Down E / Q Heading (Yaw rotation) Mouse Description Hold left button Yaw / Pitch rotation Hold right button Up / Down Hold scroll button Forward / Backward / Left/ Right Scroll Change FOV"},{"location":"controls/#implementing-custom-camera-control","title":"Implementing custom camera control","text":"<p>In case you want to directly control the camera properties, use <code>StaticCameraControl</code> and <code>StaticProjectionControl</code>. This  combination enables, for example, AR-like visualization through direct manipulation of camera pose and projection.</p> <pre><code>Eigen::Isometry3f T_world_camera = ...;   // Camera pose (X = right, Y = down, Z = forward)\nauto static_camera = std::make_shared&lt;guik::StaticCameraControl&gt;(T_world_camera);\nviewer-&gt;set_camera_control(static_camera);\nEigen::Vector2i canvas_size = viewer-&gt;canvas_size();\nEigen::Matrix3f camera_matrix = ...;  // OpenCV camera intrinsic matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]]\nauto static_projection = std::make_shared&lt;guik::StaticProjectionControl&gt;(canvas_size, camera_matrix);\nviewer-&gt;set_projection_control(static_projection);\n</code></pre>"},{"location":"controls/#model-matrix-control-imguizmo","title":"Model matrix control (ImGuizmo)","text":"<pre><code>#include &lt;guik/model_control.hpp&gt;\nEigen::Matrix4f init_model_matrix = Eigen::Matrix4f::Identity();\nguik::ModelControl model_control(\"model_control\", init_model_matrix);\nviewer-&gt;register_ui_callback(\"model_control_ui\", [&amp;]{\nmodel_control.draw_gizmo_ui();\nmodel_control.draw_gizmo();\nEigen::Matrix4f model_matrix = model_control.model_matrix();\nviewer-&gt;update_drawable(\"cube\", glk::Primitives::cube(), guik::Rainbow(model_matrix));\n});\n</code></pre> <p>Note: ImGuizmo cannot be shown twice or more in one rendering frame.</p> <p></p> <p>Guizmo can be drawn on subviewers.</p> <pre><code>auto sub = viewer-&gt;sub_viewer(\"sub\");\nauto model_control = std::make_shared&lt;guik::ModelControl&gt;(\"model_control\");\nsub-&gt;register_ui_callback(\"model_control\", [=] {\nconst ImVec2 canvas_rect_min = ImGui::GetItemRectMin();\nconst ImVec2 canvas_rect_max = ImGui::GetItemRectMax();\nconst int win_x = canvas_rect_min.x;\nconst int win_y = canvas_rect_min.y;\nconst int win_w = canvas_rect_max.x - canvas_rect_min.x;\nconst int win_h = canvas_rect_max.y - canvas_rect_min.y;\nconst Eigen::Matrix4f view_matrix = sub-&gt;get_camera_control()-&gt;view_matrix();\nconst Eigen::Matrix4f projection_matrix = sub-&gt;get_projection_control()-&gt;projection_matrix();\nmodel_control-&gt;draw_gizmo(win_x, win_y, win_w, win_h, view_matrix, projection_matrix, true);\nsub-&gt;update_coord(\"coord\", guik::VertexColor(model_control-&gt;model_matrix()));\n});\n</code></pre>"},{"location":"cookbook/","title":"Cookbook","text":""},{"location":"cookbook/#point-cloud-editor","title":"Point cloud editor","text":"<p>src/example/ext_pointcloud_editor.cpp</p> ext_pointcloud_editor.cpp <pre><code>#include &lt;glk/io/ply_io.hpp&gt;\n#include &lt;glk/pointcloud_buffer.hpp&gt;\n#include &lt;glk/indexed_pointcloud_buffer.hpp&gt;\n#include &lt;glk/primitives/primitives.hpp&gt;\n#include &lt;guik/model_control.hpp&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\n#include &lt;portable-file-dialogs.h&gt;\nclass PointCloudEditor {\npublic:\nPointCloudEditor() {\nauto viewer = guik::LightViewer::instance();\ncube_matrix.reset(new guik::ModelControl(\"cube_matrix\"));\nviewer-&gt;register_ui_callback(\"ui\", [this] { ui_callback(); });\nviewer-&gt;spin();\n}\nprivate:\nvoid ui_callback() {\nauto viewer = guik::LightViewer::instance();\nImGui::Begin(\"control\", nullptr, ImGuiWindowFlags_AlwaysAutoResize);\n// Load points    \nif (ImGui::Button(\"Load point cloud\")) {\nfor (const auto&amp; filename : pfd::open_file(\"Select a PLY file\").result()) {\n// Load points from PLY and add them to the point list\nauto ply = glk::load_ply(filename);\nif (ply) {\npoints.insert(points.end(), ply-&gt;vertices.begin(), ply-&gt;vertices.end());\n}\n}\n// Show points on the viewer\nif (!points.empty()) {\ncloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(points);\nviewer-&gt;update_drawable(\"points\", cloud_buffer, guik::Rainbow());\n}\n}\n// Save points\nif (ImGui::Button(\"Save point cloud\")) {\nauto path = pfd::save_file(\"Select a destination path to save PLY\").result();\nif (!path.empty() &amp;&amp; !points.empty()) {\nglk::save_ply_binary(path, points.data(), points.size());\n}\n}\n// Show the cube representing the filtering area\nImGui::Separator();\ncube_matrix-&gt;draw_gizmo_ui();\ncube_matrix-&gt;draw_gizmo();\nviewer-&gt;update_drawable(\"cube\", glk::Primitives::cube(), guik::FlatColor({1.0f, 0.5f, 0.0f, 0.5f}, cube_matrix-&gt;model_matrix()).make_transparent());\n// Find points in the filtering area\nif (ImGui::Button(\"Select points\")) {\n// The inverse of the cube model matrix transforms world points in the cube coordinate system\nEigen::Matrix4f inv_cube_matrix = cube_matrix-&gt;model_matrix().inverse();\nselected_points.clear();\nneg_selected_points.clear();\nfor (int i = 0; i &lt; points.size(); i++) {\nEigen::Vector3f pt = (Eigen::Affine3f(inv_cube_matrix) * points[i]);\n// Points in [(-0.5, -0.5, -0.5), (0.5, 0.5, 0.5)] are inside of the cube\nif ((pt.array() &gt; Eigen::Array3f::Constant(-0.5f)).all() &amp;&amp; (pt.array() &lt; Eigen::Array3f::Constant(0.5f)).all()) {\nselected_points.emplace_back(i);\n} else {\nneg_selected_points.emplace_back(i);\n}\n}\n// Show the selected points with large orange points\nviewer-&gt;update_drawable(\"selected\", std::make_shared&lt;glk::IndexedPointCloudBuffer&gt;(cloud_buffer, selected_points), guik::FlatOrange().set_point_scale(2.0f));\n}\n// Remove the selected points from the point list\nif (ImGui::Button(\"Remove points\")) {\n// Leave only \"un\"selected points\nstd::vector&lt;Eigen::Vector3f&gt; filtered;\nstd::transform(neg_selected_points.begin(), neg_selected_points.end(), std::back_inserter(filtered), [&amp;](const auto i) { return points[i]; });\npoints = std::move(filtered);\nselected_points.clear();\nneg_selected_points.clear();\ncloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(points);\nviewer-&gt;update_drawable(\"points\", cloud_buffer, guik::Rainbow());\nviewer-&gt;remove_drawable(\"selected\");\n}\nImGui::End();\n}\nprivate:\nstd::unique_ptr&lt;guik::ModelControl&gt; cube_matrix;      // Model matrix of the cube representing the filtering area\nstd::vector&lt;Eigen::Vector3f&gt; points;                  // Point cloud\nstd::shared_ptr&lt;glk::PointCloudBuffer&gt; cloud_buffer;  // CloudBuffer of points\nstd::vector&lt;unsigned int&gt; selected_points;            // Selected points\nstd::vector&lt;unsigned int&gt; neg_selected_points;        // Negative of selected points\n};\nint main(int argc, char** argv) {\nPointCloudEditor editor;\nreturn 0;\n}\n</code></pre> <ul> <li>PLY file IO with portable-file-dialogs</li> <li>Gizmo-based model matrix control</li> <li>Point cloud rendering using <code>PointCloudBuffer</code> and <code>IndexedPointCloudBuffer</code></li> </ul>"},{"location":"drawables/","title":"Drawables","text":"<p>Examples of lines, 3D primitives, and 2D drawings (Code): </p>"},{"location":"drawables/#shorthand-methods","title":"Shorthand methods","text":"<p>For frequently used drawable types, <code>guik::LightViewer</code> provides shorthand methods to quickly create and update drawables.</p> <pre><code>// Primitives\nviewer-&gt;update_sphere(\"sphere\", guik::FlatRed());\nviewer-&gt;update_wire_sphere(\"wire_sphere\", guik::FlatRed());\nviewer-&gt;update_coord(\"coord\", guik::VertexColor());\nviewer-&gt;update_wire_frustum(\"frustum\", guik::FlatGreen());\n// PointCloudBuffer\n// Any of Vector(3|4)(f|d) are allowed as input\nstd::vector&lt;Eigen::Vector4d&gt; points = ...;\nviewer-&gt;update_points(\"points\", points, guik::Rainbow());\n// NormalDistributions\nstd::vector&lt;Eigen::Vector3f&gt; means = ...;\nstd::vector&lt;Eigen::Matrix3f&gt; covs = ...;\nfloat scale = 1.0f;\nviewer-&gt;update_normal_dists(\"normal_dists\", means, covs, scale, guik::Rainbow());)\n// ThinLine\nstd::vector&lt;Eigen::Vector3f&gt; line_vertices = ...;\nbool line_strip = true;\nviewer-&gt;update_thin_lines(\"lines\", line_vertices, true, guik::FlatGreen());\n</code></pre>"},{"location":"drawables/#3d-primitives","title":"3D Primitives","text":"<ul> <li>Icosahedron</li> <li>Sphere</li> <li>Stanford bunny</li> <li>Cube</li> <li>Cone</li> <li>Coordinate system</li> <li>Frustum</li> </ul> <pre><code>#include &lt;glk/primitives/primitives.hpp&gt;\n// Solid and wire icosahedrons\nglk::Primitives::icosahedron();\nglk::Primitives::wire_icosahedron();\n// Solid and wire spheres\nglk::Primitives::sphere();\nglk::Primitives::wire_sphere();\n// Solid and wire bunnies\nglk::Primitives::bunny();\nglk::Primitives::wire_bunny();\n// Solid and wire cubes\nglk::Primitives::cube();\nglk::Primitives::wire_cube();\n// Solid and wire cones\nglk::Primitives::cone();\nglk::Primitives::wire_cone();\n// RGB-colored coordinate systems rendered using GL_LINES and polygons\n// They should be rendered with guik::VertexColor\nglk::Primitives::coordinate_system();\nglk::Primitives::solid_coordinate_system();\n// Wire frustum for representing a camera pose (+Z=front)\nglk::Primitives::wire_frustum();\n</code></pre>"},{"location":"drawables/#lines","title":"Lines","text":"<p>glk::ThinLines draws lines with GL_LINES.  The thickness of lines is independent of the viewpoint.</p> <pre><code>#include &lt;glk/thin_lines.hpp&gt;\n// Line vertices\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\n// If line_strip == true, lines are drawn between adjacent vertices (GL_LINE_STRIP).\n// If line_strip == false, lines are drawn between vertices[i * 2] and vertices[i * 2 + 1] (GL_LINES).\nbool line_strip = true;\n// Create lines (All vertices are processed in order)\nauto lines = std::make_shared&lt;glk::ThinLines&gt;(vertices, line_strip);\n// Create lines with indexing\nstd::vector&lt;unsigned int&gt; indices = ...;\nauto lines_with_indices = std::make_shared&lt;glk::ThinLines&gt;(vertices, indices, line_strip);\n// Create lines with vertex colors\nstd::vector&lt;Eigen::Vector4f&gt; colors = ...;\nauto lines_with_colors = std::make_shared&lt;glk::ThinLines&gt;(vertices, colors, line_strip);\n// Set line width (glLineWidth)\nlines-&gt;set_line_width(2.0f);\n</code></pre> <p>glk::Lines draws lines with polygons. The thickness of lines changes depending on the viewpoint and perspective. <pre><code>#include &lt;glk/thin_lines.hpp&gt;\nfloat line_width = 0.1f;\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\nstd::vector&lt;Eigen::Vector4f&gt; colors = ...;\nbool line_strip = true;\nauto lines = std::make_shared&lt;glk::Lines&gt;(line_width, vertices, colors, line_strip);\n</code></pre></p> <p></p>"},{"location":"drawables/#point-cloud","title":"Point cloud","text":"<p>glk::PointCloudBuffer holds and renders a 3D point cloud.</p> <pre><code>#include &lt;glk/pointcloud_buffer.hpp&gt;\n// Create PointCloudBuffer from std::vector&lt;Eigen::Vector3f&gt;\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(vertices);\n// Add vertex colors\nstd::vector&lt;Eigen::Vector4f&gt; colors = ...;\ncloud_buffer-&gt;add_color(colors);\n// Add vertex colors that encode scalar values in [0, 1]\nstd::vector&lt;double&gt; intensities = ...;\ncloud_buffer-&gt;add_intensity(glk::COLORMAP::TURBO, intensities);\n// Add vertex normals\nstd::vector&lt;Eigen::Vector3f&gt; normals = ...;\ncloud_buffer-&gt;add_normals(normals);\n// Add AUX point property\nstd::vector&lt;float&gt; values = ...;\nint dim = 1;\ncloud_buffer-&gt;add_buffer(\"radius\", dim, values.data(), sizeof(float) * dim, values.size());\n// Enlarge point size\nauto shader_setting = guik::Rainbow().set_point_scale(2.0f);\nviewer-&gt;update_drawable(\"points\", cloud_buffer, shader_setting);\n</code></pre> <p> <code>glk::PointCloudBuffer</code> rendered with <code>guik::Rainbow</code></p> <p>glk::IndexedPointCloudBuffer enables specifying the indices of vertices to be rendered.</p> <pre><code>#include &lt;glk/indexed_pointcloud_buffer.hpp&gt;\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(vertices);\nstd::vector&lt;unsigned int&gt; indices = ...;\nauto indexed_buffer = std::make_shared&lt;glk::IndexedPointCloudBuffer&gt;(cloud_buffer, indices);\n</code></pre>"},{"location":"drawables/#point-shape","title":"Point shape","text":"<p>The point shape (rectangles by default) can be changed to circles by setting <code>point_shape_mode=PointShapeMode::CIRCLE</code>.</p> <pre><code>auto viewer = guik::viewer();\nguik::ShaderSetting&amp; global_setting = viewer-&gt;shader_setting();\nglobal_setting.set_point_shape_mode(guik::PointShapeMode::RECTANGLE);  // Set default point shape mode to RECTANGLE. Alternatively, global_setting.set_point_shape_rectangle() can be used.\nglobal_setting.set_point_shape_mode(guik::PointShapeMode::CIRCLE);     // Set default point shape mode to CIRCLE. Alternatively, global_setting.set_point_shape_circle() can be used.\n</code></pre>"},{"location":"drawables/#point-scale","title":"Point scale","text":"<p>Screen space scaling (default) The size of points is computed as <code>radius_pix = point_scale * point_size * nz + point_size_offset</code>, where <code>nz</code> is the fragment screen space depth in [0, 1]. By default <code>point_scale=1.0</code>, <code>point_size=10.0</code>, <code>point_size_offset=0.0</code>, and they can be updated by setting values to <code>guik::ShaderSetting</code>.</p> <pre><code>auto viewer = guik::viewer();\nguik::ShaderSetting&amp; global_setting = viewer-&gt;shader_setting();\nglobal_setting.set_point_scale_screenspace();   // Set the point scale mode to screenspace\nglobal_setting.set_point_size(5.0f);            // Set the base point size to 5.0\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(...);\n// Make the size of points as twice large as the base point size\nviewer-&gt;update_drawable(\"points\", cloud_buffer, guik::FlatBlue().set_point_scale(2.0f));\n</code></pre> <p>Metric space scaling The size of points is computed based on the physical size specified as <code>radius_m = point_scale * point_size + point_size_offset</code>.</p> <pre><code>auto viewer = guik::viewer();\nguik::ShaderSetting&amp; global_setting = viewer-&gt;shader_setting();\nglobal_setting.set_point_shape_circle();\nglobal_setting.set_point_scale_metric();\nglobal_setting.set_point_size(0.5f);  // Set default point radius to 0.5\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(...);\n// Set point radius to 0.5\nviewer-&gt;update_drawable(\"points\", cloud_buffer, guik::FlatBlue().set_point_size(0.5f));\n</code></pre> <p> Red : Wire spheres (radius=0.5), Blue : Points rendered with PointCloudBuffer (<code>point_shape_mode=CIRCLE</code>, <code>point_scale_mode=METRIC</code>, <code>point_size=0.5</code>).</p>"},{"location":"drawables/#normal-distributions","title":"Normal distributions","text":"<p>glk::NormalDistributions</p> <pre><code>#include &lt;glk/normal_distributions.hpp&gt;\nstd::vector&lt;Eigen::Vector3f&gt; means = ...;\nstd::vector&lt;Eigen::Matrix3f&gt; covs = ...;\nfloat scale = 1.0f;\nauto normal_distributions = std::make_shared&lt;glk::NormalDistributions&gt;(means, covs, scale);\n</code></pre>"},{"location":"drawables/#point-splatting","title":"Point splatting","text":"<p>glk::Splatting</p> <pre><code>#include &lt;glk/splatting.hpp&gt;\n// Create a PointCloudBuffer with normals\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\nstd::vector&lt;Eigen::Vector3f&gt; normals = ...;\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(vertices);\ncloud_buffer-&gt;add_normals(normals);\n// Create a splatting shader\nauto splatting_shader = glk::create_splatting_shader();\n// Create a splatting instance\nfloat point_radius = 0.1f;\nauto splatting = std::make_shared&lt;glk::Splatting&gt;(splatting_shader);\nsplatting-&gt;set_point_radius(point_radius);\nsplatting-&gt;set_cloud_buffer(cloud_buffer);\n// If vertex radius is enabled, the radius of each point is calculated as point_radius * vertex's radius.\n// Otherwise, the fixed point_radius is used for rendering all points.\nsplatting-&gt;enable_vertex_radius();\nstd::vector&lt;float&gt; radii = ...;\ncloud_buffer-&gt;add_buffer(\"radius\", 1, radii.data(), sizeof(float), radii.size());\n</code></pre> <p> Sparse point cloud</p> <p> Sparse point cloud rendered using <code>glk::Splatting</code></p> <p> Closer look at the splatting result: Points are rendered as oriented disks</p>"},{"location":"drawables/#mesh","title":"Mesh","text":"<pre><code>#include &lt;glk/mesh.hpp&gt;\nstd::vector&lt;Eigen::Vector3f&gt; vertices = ...;\nstd::vector&lt;Eigen::Vector3f&gt; normals = ...;\nstd::vector&lt;Eigen::Vector4f&gt; colors = ...;\nstd::vector&lt;Eigen::Vector2f&gt; tex_coords;\nstd::vector&lt;unsigned int&gt; indices;\n// Create a mesh instance\n// Pass nullptr if normal/color/tex_coord is not available\nauto mesh = std::make_shared&lt;glk::Mesh&gt;(\nvertices.data(), sizeof(float) * 3,\nnormals.data(), sizeof(float) * 3,\ncolors.data(), sizeof(float) * 4,\ntex_coords.data(), sizeof(float) * 2,\nvertices.size()\nindices.data(),\nindices.size()\n);\nstd::shared_ptr&lt;glk::Texture&gt; texture = ...;\nmesh-&gt;set_texture(texture);\n</code></pre>"},{"location":"drawables/#2d-drawings","title":"2D Drawings","text":"<p>guik::HoveredDrawings projects 3D object positions on the screen and draws 2D primitives on the projected positions.</p> <pre><code>#include &lt;guik/hovered_drawings.hpp&gt;\n// Create hovered drawings renderer and register it to the viewer\nauto hovered = std::make_shared&lt;guik::HoveredDrawings&gt;();\nviewer-&gt;register_ui_callback(\"hovered\", hovered-&gt;create_callback());\n// Draw a text at a fixed 3D position (1.0, 2.0, 3.0)\nstd::uint32_t fg_color = IM_COL32(255, 255, 255, 255);\nstd::uint32_t bg_color = IM_COL32(0, 0, 0, 128);\nhovered-&gt;add_text({1.0f, 2.0f, 3.0f}, \"text1\", fg_color, bg_color);\n// Instead of directly giving a 3D position, a drawable name can be \n// used to draw a 2D drawing on the drawable position\nhovered-&gt;add_text_on(\"drawable_name\", \"text2\", fg_color, bg_color);\n// Cross\nEigen::Vector3f position = {1.0f, 2.0f, 3.0f};\nstd::uint32_t color = IM_COL32(255, 255, 255, 255);\nfloat size = 10.0f;\nhovered-&gt;add_cross(position, color, size);\n// Circle\nfloat radius = 10.0f;\nhovered-&gt;add_circle(position, color, radius);\n// Triangle\nfloat height = 20.0f;\nhovered-&gt;add_triangle(position, color, height);\nhovered-&gt;add_filled_triangle(position, color, height);\n// Rectangle\nEigen::Vector2f size = {10.0f, 10.0f};\nEigen::Vector2f offset = {0.0f, 0.0f};\nhovered-&gt;add_rect(position, color, size, offset);\nhovered-&gt;add_filled_rect(position, color, size, offset);\n// Image (glk::Texture)\nstd::make_shared&lt;glk::Texture&gt; texture = ...;\nhovered-&gt;add_image(position, texture, size, offset);\n</code></pre> <p></p> <p>guik::HoveredDrawings can be drawn on subviewers.</p> <pre><code>auto sub = viewer-&gt;sub_viewer(\"sub\");\nauto hovered = std::make_shared&lt;guik::HoveredDrawings&gt;(sub);\nhovered-&gt;add_rect_on(\"coord\", IM_COL32(0, 255, 0, 255));\nsub-&gt;register_ui_callback(\"hovered\", hovered-&gt;create_callback());\n</code></pre>"},{"location":"drawables/#image-2d-texture","title":"Image (2D texture)","text":"<pre><code>#include &lt;glk/texture.hpp&gt;\n// Create a texture from raw pixel data\nEigen::Vector2i size = ...;\nGLuint internal_format = GL_RGBA;\nGLuint format = GL_RGB;\nGLuint type = GL_UNSIGNED_BYTE;\nstd::vector&lt;unsigned char&gt; pixels = ...;\nauto texture = std::make_shared&lt;glk::Texture&gt;(size, internal_format, format, type, pixels.data());\n// Register the image to the viewer\nviewer-&gt;update_image(\"image\", texture);\n</code></pre> <p>There is also a utility function to create a texture from <code>cv::Mat</code>. <pre><code>#include &lt;glk/texture_opencv.hpp&gt;\ncv::Mat image = ...;\nauto texture = glk::create_texture(image);\nviewer-&gt;update_image(\"image\", texture);\n</code></pre></p> <p></p> <p>If an image name contains '/', the string before the slash is recognized as a group name, and images with the same group name are grouped in a tab.</p> <pre><code>viewer-&gt;update_image(\"group0/image0\", texture);\nviewer-&gt;update_image(\"group0/image1\", texture);\nviewer-&gt;update_image(\"group1/image0\", texture);\n</code></pre> <p></p>"},{"location":"drawables/#plots-implot","title":"Plots (ImPlot)","text":"<pre><code>#include &lt;implot.h&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\nstd::vector&lt;double&gt; xs = ...;\nstd::vector&lt;double&gt; ys = ...;\n// Basic plotting\nviewer-&gt;setup_plot(\"curves_y\", 1024, 256);\nviewer-&gt;update_plot_line(\"curves_y\", \"sin\", ys_sin);  // When only Y values are given, X values become index IDs\nviewer-&gt;update_plot_stairs(\"curves_y\", \"sin_stairs\", ys_sin);\nstd::vector&lt;double&gt; xs_circle = ...;\nstd::vector&lt;double&gt; ys_circle = ...;\n// If a plot name contains \"/\", the string before the slash is recognized as a group name.\n// Plots with the same group name are displayed in the same tab.\nviewer-&gt;setup_plot(\"group02/circle\", 1024, 1024, ImPlotFlags_Equal);\nviewer-&gt;update_plot_line(\"group02/circle\", \"circle\", xs_circle, ys_circle, ImPlotLineFlags_Loop);\n</code></pre>"},{"location":"effects/","title":"Screen space effect","text":"<p>(Documentation unfinished)</p>"},{"location":"effects/#screen-space-attribute-estimation","title":"Screen space attribute estimation","text":""},{"location":"effects/#input-image-without-screen-effects","title":"Input image without screen effects","text":""},{"location":"effects/#naive-screen-space-ambient-occlusion","title":"Naive screen space ambient occlusion","text":"<pre><code>#include &lt;glk/effects/naive_screen_space_ambient_occlusion.hpp&gt;\nauto ssao = std::make_shared&lt;glk::NaiveScreenSpaceAmbientOcclusion&gt;();\nviewer-&gt;set_screen_effect(ssao);\n</code></pre>"},{"location":"effects/#smoothed-screen-space-ambient-occlusion","title":"Smoothed screen space ambient occlusion","text":"<pre><code>#include &lt;glk/effects/screen_space_ambient_occlusion.hpp&gt;\nauto ssao = std::make_shared&lt;glk::ScreenSpaceAmbientOcclusion&gt;();\nviewer-&gt;set_screen_effect(ssao);\n</code></pre>"},{"location":"effects/#screen-space-lighting","title":"Screen space lighting","text":"<pre><code>#include &lt;glk/effects/screen_space_lighting.hpp&gt;\nEigen::Vector3f light0_pos(1.0f, 1.0f, 5.0f);\nEigen::Vector4f light0_color(2.0f, 2.0f, 2.0f, 1.0f);\nEigen::Vector3f light1_pos(0.0f, -2.0f, 2.0f);\nEigen::Vector4f light1_color(0.5f, 0.5f, 0.5f, 1.0f);\nauto lighting_effect = std::make_shared&lt;glk::ScreenSpaceLighting&gt;();\nlighting_effect-&gt;set_light(0, light0_pos, light0_color);\nlighting_effect-&gt;set_light(1, light1_pos, light1_color);\nviewer-&gt;enable_normal_buffer();\nviewer-&gt;set_screen_effect(lighting_effect);\n</code></pre>"},{"location":"misc/","title":"Miscellaneous","text":""},{"location":"misc/#enablingdisabling-vsync","title":"Enabling/Disabling Vsync","text":"<p>By default, vsync is enabled and the maximum FPS is limited to the refresh rate of the display. The maximum FPS can be unbounded by disabling vsync.</p> <pre><code>// Disable vsync to unlimit the maximum FPS\nviewer-&gt;disable_vsync();\n// Enable vsync to limit the maximum FPS\nviewer-&gt;enable_vsync();\n</code></pre>"},{"location":"misc/#spin-methods","title":"Spin methods","text":"<p>In addition to <code>spin_once()</code> and <code>spin()</code>, there are two utility methods for spinning the viewer, <code>spin_until_click()</code> and <code>toggle_spin_once()</code> that are useful for debugging.</p> <p><code>spin_until_click()</code> spins the viewer until the <code>break</code> button gets clicked for step-by-step debugging. <pre><code>double angle = 0.0;\nwhile (viewer-&gt;spin_until_click()) {\nviewer-&gt;update_drawable(\"cube\", glk::Primitives::cube(), guik::Rainbow().rotate(angle, {0.0f, 0.0f, 1.0f}));\nangle += 0.1;\n}\n</code></pre></p> <p></p> <p><code>toggle_spin_once()</code> spins the viewer and stops while the <code>break</code> checkbox is checked. <pre><code>double angle = 0.0;\nwhile(viewer-&gt;toggle_spin_once()) {\nviewer-&gt;update_drawable(\"cube\", glk::Primitives::cube(), guik::Rainbow().rotate(angle, {0.0f, 0.0f, 1.0f}));\nangle += 0.01;\n}\n</code></pre> </p>"},{"location":"misc/#background-colorimage","title":"Background color/image","text":"<pre><code>// Change the background color\nviewer-&gt;set_clear_color({0.2f, 0.2f, 0.2f, 1.0f});\n// Set a background image\nstd::shared_ptr&lt;glk::Texture&gt; texture = ...;\nviewer-&gt;set_bg_texture(texture);\n</code></pre>"},{"location":"misc/#text-output","title":"Text output","text":"<pre><code>viewer-&gt;append_text(\"text1\");\nviewer-&gt;append_text(\"text2\");\n</code></pre>"},{"location":"misc/#removing-drawables","title":"Removing drawables","text":"<pre><code>// Remove a drawable with a specified name\nviewer-&gt;remove_drawable(\"drawable_name\");\n// Removes drawables with names that match a regex pattern\nviewer-&gt;remove_drawable(std::regex(\"drawable_.+\"));\n// Remove all drawables\nviewer-&gt;clear_drawables();\n</code></pre>"},{"location":"misc/#drawable-filter","title":"Drawable filter","text":"<pre><code>viewer-&gt;register_drawable_filter(\"filter\", [](const std::string&amp; drawable_name) {\nbool do_rendering = true;\nif (drawable_name == \"drawable_to_be_filtered\") {\ndo_rendering = false;\n}\nreturn do_rendering;\n});\n// Drawable filter can be removed by overwriting with 0\nviewer-&gt;register_drawable_filter(\"filter\", 0);\n</code></pre>"},{"location":"misc/#changing-the-coloring-settings-of-the-rainbow-scheme","title":"Changing the coloring settings of the Rainbow scheme","text":"<pre><code>glk::COLORMAP colormap = glk::COLORMAP::AUTUMN;   // Colormap type\nEigen::Vector2f range(-3.0f, 5.0f);               // Coloring range\nEigen::Vector3f axis(1.0f, 0.0f, 0.0f);           // Coloring axis\nviewer-&gt;set_colormap(colormap);\nviewer-&gt;shader_setting().add(\"z_range\", range);\nviewer-&gt;shader_setting().add(\"colormap_axis\", axis);\n</code></pre>"},{"location":"misc/#colormaps","title":"Colormaps","text":"<pre><code>#include &lt;glk/colormap.hpp&gt;\n// Get colormap value (integer version: value range = [0, 255])\nEigen::Vector4i color = colormap(glk::COLORMAP::TURBO, 128);\n// Get colormap value (float version: value range = [0.0, 1.0])\nEigen::Vector4f colorf = colormapf(glk::COLORMAP::TURBO, 0.5f);\n// Get a caterogical color by evenly sampling colors from a colormap\n// The color loops every \"num_categories\" counts\nint count = 1;\nint num_categories = 16;\nEigen::Vector4i cat_color = colormap_categorical(glk::COLORMAP::TURBO, count, num_categories);\n// Float version\nEigen::Vector4f cat_colorf = colormap_categoricalf(glk::COLORMAP::TURBO, count, num_categories);\n</code></pre>"},{"location":"misc/#sub-viewer","title":"Sub-viewer","text":"<pre><code>auto sub_viewer1 = viewer-&gt;sub_viewer(\"sub1\");\nsub_viewer1-&gt;update_drawable(\"cube\", glk::Primitives::cube(), guik::Rainbow());\nauto sub_viewer2 = viewer-&gt;sub_viewer(\"sub2\");\nsub_viewer2-&gt;update_drawable(\"sphere\", glk::Primitives::sphere(), guik::Rainbow());\n</code></pre>"},{"location":"misc/#sharing-the-default-camera-control-with-sub-viewers","title":"Sharing the default camera control with sub-viewers","text":"<pre><code>auto camera_control = viewer-&gt;get_camera_control();\nsub_viewer1-&gt;set_camera_control(camera_control);\nsub_viewer2-&gt;set_camera_control(camera_control);\n</code></pre>"},{"location":"misc/#taking-screenshot","title":"Taking screenshot","text":"<p>Simple but slow screen capture methods (1~30 FPS): <pre><code>// 8-bit RGBA pixel data\nstd::vector&lt;unsigned char&gt; color_pixels = viewer-&gt;read_color_buffer();\n// float depth data\nstd::vector&lt;float&gt; depth_pixels = viewer-&gt;read_depth_buffer();\n</code></pre></p> <p>For efficient asynchronous screen data transfer with pixel buffer objects (~500FPS), see src/example/ext_light_viewer_capture.cpp</p>"},{"location":"misc/#file-dialogs-portable-file-dialogs","title":"File dialogs (portable-file-dialogs)","text":"<pre><code>#include &lt;portable-file-dialogs.h&gt;\n#include &lt;guik/recent_files.hpp&gt;\nguik::RecentFiles recent_files(\"input_directory\");\nconst std::string path = pfd::select_folder(\"Select input directory\", recent_files.most_recent()).result();\nif (!path.empty()) {\nrecent_files.push(path);\n}\n</code></pre>"},{"location":"misc/#logging-spdlog","title":"Logging (spdlog)","text":"<pre><code>#include &lt;spdlog/spdlog.h&gt;\n#include &lt;spdlog/sinks/ringbuffer_sink.h&gt;\n#include &lt;guik/spdlog_sink.hpp&gt;\n#include &lt;guik/viewer/light_viewer.hpp&gt;\n// Setup a ringbuffer sink for the default spdlog logger\nconst int ringbuffer_size = 100;\nauto ringbuffer_sink = std::make_shared&lt;spdlog::sinks::ringbuffer_sink_mt&gt;(ringbuffer_size);\nauto logger = spdlog::default_logger();\nlogger-&gt;sinks().emplace_back(ringbuffer_sink);\nlogger-&gt;set_level(spdlog::level::trace);\nspdlog::trace(\"trace\");\nspdlog::debug(\"debug\");\nspdlog::info(\"info\");\nspdlog::warn(\"warning\");\nspdlog::error(\"error\");\n// Create a logger UI to display ringbuffer contents\nconst double bg_alpha = 0.7;\nviewer-&gt;register_ui_callback(\"logging\", guik::create_logger_ui(ringbuffer_sink, bg_alpha));\n</code></pre>"},{"location":"misc/#image-and-3d-model-io","title":"Image and 3D model IO","text":""},{"location":"misc/#png","title":"PNG","text":"<pre><code>#include &lt;glk/io/png_io.hpp&gt;\n// Load PNG image\n// Pixel data are stored in 8-bit RGBA format\nint width, height;\nstd::vector&lt;unsigned char&gt; pixels;\nglk::load_png(\"image.png\", width, height, pixels);\n// Save image as a PNG image\n// Pixel data must be 8-bit RGBA\nglk::save_png(\"image.png\", width, height, pixels);\n</code></pre>"},{"location":"misc/#jpeg","title":"JPEG","text":"<pre><code>#include &lt;glk/io/jpeg_io.hpp&gt;\n// Load JPEG image\n// Pixel data are stored in 8-bit RGBA format\nint width, height;\nstd::vector&lt;unsigned char&gt; pixels;\nglk::load_jpeg(\"image.png\", width, height, pixels);\n// Save image as a JPEG image\n// Pixel data must be 8-bit RGBA\nint quality = 100;\nglk::save_jpeg(\"image.png\", width, height, pixels, quality);\n</code></pre>"},{"location":"misc/#ply","title":"PLY","text":"<pre><code>#include &lt;glk/io/ply_io.hpp&gt;\n// Load a PLY model\nauto ply = glk::load_ply(\"model.ply\");\n// ply-&gt;vertices    : std::vector&lt;Eigen::Vector3f&gt;\n// ply-&gt;colors      : std::vector&lt;Eigen::Vector4f&gt;\n// ply-&gt;normals     : std::vector&lt;Eigen::Vector3f&gt;\n// ply-&gt;intensities : std::vector&lt;float&gt;\n// ply-&gt;indices     : std::vector&lt;int&gt;\n// Save a PLY data\nglk::save_ply_binary(\"model.ply\", *ply);\n// Save a point cloud in the PLY format\nstd::vector&lt;Eigen::Vector3f&gt; points\nglk::save_ply_binary(\"model.ply\", points.data(), points.size());\n</code></pre>"},{"location":"misc/#partial-point-cloud-rendering","title":"Partial point cloud rendering","text":"<p>The rendering cost of large static point cloud can be mitigated with the partial rendering mode. In this mode, only a part of static point clouds are rendered every frame and accumulated over time. Although this causes flickering, it can drastically increase the rendering speed.</p> <ol> <li>Enable the partial rendering mode for the viewer. <code>viewer-&gt;enable_partial_rendering()</code>.</li> <li>Create a point cloud buffer and set the points rendering budget. <pre><code>auto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(...);\nint points_rendering_budget = 512;\ncloud_buffer-&gt;enable_partial_rendering(points_rendering_budget);\n</code></pre></li> <li>Mark the drawable as a static object.     <pre><code>viewer-&gt;update_drawable(\"points\", cloud_buffer, guik::Rainbow().static_object());\n</code></pre></li> <li>Mark other objects as dynamic.     <pre><code>viewer-&gt;update_cube(\"cube\", guik::FlatBlue().dynamic_object());\n</code></pre></li> </ol> <p>See also ext_light_viewer_partial_rendering.cpp.</p> <p></p> <p>Note</p> <p>This feature may not work well on non-NVIDIA GPUs.</p>"},{"location":"misc/#viewer-menu","title":"Viewer menu","text":"<p>By pressing \"Ctrl+M\", a hidden menu bar appears. Via the manu bar, you can:</p> <ul> <li>Change the rainbow colormap, coloring axis and range</li> <li>Show an information window (FPS/CPU&amp;GPU Usage)</li> <li>Enable/Disable vsync</li> <li>Enable/Disable XY grid</li> <li>Show drawable filter and editor</li> <li>Save/Load the camera setting</li> <li>Get 3D positions of objects via point picking</li> </ul> <p></p>"},{"location":"misc/#keyboard-shortcut","title":"Keyboard shortcut","text":""},{"location":"misc/#general","title":"General","text":"Key Description Ctrl + M Show viewer menu Ctrl + J Save screenshot Ctrl + F Fit all plots to data Ctrl + MINUX / PLUS Increase / decrease point scale"},{"location":"misc/#camera-control","title":"Camera control","text":"Key Description Ctrl + Arrow Move camera Ctrl + Page UP / Down Zoom in/out Ctrl + Home / End Increase / decrease moving speed (permanently) Shift Increase moving speed (while holding)"},{"location":"multithread/","title":"Multi-threading","text":""},{"location":"multithread/#invoke","title":"Invoke","text":"<p>Because OpenGL commands can only be executed on a single GUI context thread, most of functionalities of Iridescence are also required to be executed on the single GUI thread. For safely updating visualization contents, Iridescence provides <code>invoke()</code> method that pushes a task (functor) to a thread-safe task queue and requests the viewer to execute it on the GUI thread.</p> <pre><code>// This function is executed in a background thread\nvoid async_update() {\nfor (int i=0; i&lt;100; i++) {\n// Prepare point cloud data to be rendered\nstd::shared_ptr&lt;std::vector&lt;Eigen::Vector3f&gt;&gt; points = ...;\n// Creating a PointCloudBuffer here is not allowed because OpenGL objects\n// must be created in the thread where the OpenGL context was created.\n// \n// The following line does not work here!!\n// auto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(*points);\nauto viewer = guik::LightViewer::instance();\n// Requst the viewer to execute the following function in the GUI thread.\nviewer-&gt;invoke([=] {\n// This lambda function will be evaluated in the GUI thread lately.\nauto cloud_buffer = std::make_shared&lt;glk::PointCloudBuffer&gt;(*points);\nviewer-&gt;update_drawable(\"poits\", cloud_buffer, guik::Rainbow());\n});\n}\n}\nint main(int argc, char** argv) {\n// OpenGL context is created on the thread where the first call of LightViewer::instance() was made.\n// We thus recommend calling it in the main thread before using any visualization operations.\nauto viewer = guik::LightViewer::instance();\nstd::thread thread(async_update);\nviewer-&gt;spin();\nreturn 0;\n}\n</code></pre>"},{"location":"multithread/#thread-safe-operations","title":"Thread-safe operations","text":"<p><code>append_text</code> and <code>clear_text</code> are thread-safe.</p> <pre><code>viewer-&gt;append_text(\"test\");\nviewer-&gt;clear_text();\n</code></pre>"},{"location":"multithread/#asyncviewer","title":"AsyncViewer","text":"<p>If you want to keep the viewer interactive while your program is doing some blocking operations, <code>guik::AsyncLightViewer</code> would be helpful. This class creates the viewer instance in a background thread and performs visualization tasks in a way thread safe. See <code>06_light_viewer_async.cpp</code>.</p> <pre><code>#include &lt;guik/viewer/async_light_viewer.hpp&gt;\nint main(int argc, char** argv) {\n// AsyncViewer creates and runs the viewer in a background thread.\nauto async_viewer = guik::async_viewer();\n// Use AsyncViewer interfaces for safe viewer data manipulation.\n// AsyncViewer will be kept interactive even while the main thread is sleeping.\nstd::this_thread::sleep_for(std::chrono::seconds(1));\nasync_viewer-&gt;update_wire_sphere(\"sphere1\", guik::FlatRed().translate(0.0f, 0.0f, 0.0f));\nstd::this_thread::sleep_for(std::chrono::seconds(1));\nasync_viewer-&gt;update_wire_sphere(\"sphere2\", guik::FlatGreen().translate(2.0f, 0.0f, 0.0f));\n// Wait for the viewer to be closed.\nguik::async_wait();\n}\n</code></pre> <p>Warning</p> <p>Because AsyncViewer runs the viewer in a background thread, calling the standard viewer functions in this main thread is unsafe.</p> <pre><code>  auto async_viewer = guik::async_viewer();\n// The below line may cause segfaults and program crashes.\n// guik::viewer()-&gt;update_sphere(\"sphere0\", guik::FlatBlue());\n</code></pre>"},{"location":"picking/","title":"Point picking","text":""},{"location":"picking/#getting-the-clicked-position","title":"Getting the clicked position","text":"<pre><code>viewer-&gt;register_ui_callback(\"ui\", [&amp;] {\nauto&amp; io = ImGui::GetIO();\n// If right clicked the GL canvas\nif (!io.WantCaptureMouse &amp;&amp; io.MouseClicked[ImGuiMouseButton_Right]) {\n// Pick the depth of the clicked pixel\nfloat depth = viewer-&gt;pick_depth({io.MousePos.x, io.MousePos.y});\n// If depth &lt; 1.0f, the clicked pixel is a foreground object. Otherwise, it is the background.\nif(depth &lt; 1.0f) {\n// Compute the 3D position of the clicked pixel\nEigen::Vector3f pos = viewer-&gt;unproject({io.MousePos.x, io.MousePos.y}, depth);\nviewer-&gt;update_drawable(\"sphere\", glk::Primitives::sphere(), guik::FlatRed().translate(pos).scale(0.05));\n}\n}\n});\n</code></pre> <p>There is also a convenient method <code>pick_point()</code> that check if the clicked point has valid 3D coordinates. <pre><code>viewer-&gt;register_ui_callback(\"ui\", [&amp;] {\nint button = ImGuiMouseButton_Right;\nstd::optional&lt;Eigen::Vector3f&gt; pt = viewer-&gt;pick_point(button);\nif (pt) {\nstd::cout &lt;&lt; \"clicked point=\" &lt;&lt; pt-&gt;transpose() &lt;&lt; std::endl;\n}\n}\n</code></pre></p>"},{"location":"picking/#getting-the-clicked-object-information","title":"Getting the clicked object information","text":"<pre><code>// Enable information buffer\nviewer-&gt;enable_info_buffer();\n// Draw green and blue cubes with info_values == {1, 0, 0, 0} and {2, 0, 0, 0} respectively\nviewer-&gt;update_drawable(\"cube1\", glk::Primitives::cube(),\nguik::FlatGreen().add(\"info_values\", Eigen::Vector4i(1, 0, 0, 0)));\nviewer-&gt;update_drawable(\"cube2\", glk::Primitives::cube(),\nguik::FlatBlue().add(\"info_values\", Eigen::Vector4i(2, 0, 0, 0)).translate({2.0, 0.0, 0.0}));\nviewer-&gt;register_ui_callback(\"ui\", [&amp;] {\nauto&amp; io = ImGui::GetIO();\nif (!io.WantCaptureMouse &amp;&amp; io.MouseClicked[ImGuiMouseButton_Right]) {\nfloat depth = viewer-&gt;pick_depth({io.MousePos.x, io.MousePos.y});\n// If the clicked pixel is a foreground object\nif (depth &lt; 1.0f) {\n// Pick the info_values of the clicked pixel\nEigen::Vector4i info = viewer-&gt;pick_info({io.MousePos.x, io.MousePos.y});\nif (info[0] == 1) {\nviewer-&gt;append_text(\"Green cube clicked!!\");\n} else if (info[0] == 2) {\nviewer-&gt;append_text(\"Blue cube clicked!!\");\n}\n}\n}\n});\n</code></pre>"},{"location":"shader/","title":"Shader setting","text":""},{"location":"shader/#shader-setting_1","title":"Shader setting","text":"<p>guik::ShaderSetting class holds rendering parameters of a drawable object (e.g., color mode and model matrix) to control the rendering process of the assigned object.</p> <pre><code>// A sphere drawable object\nstd::shared_ptr&lt;glk::Drawable&gt; drawable = glk::Primitives::sphere();\n// guik::ShaderSetting holds rendering parameters\nint color_mode = glk::ColorMode::RAINBOW;\nEigen::Matrix4f transformation = Eigen::Matrix4f::Identity();\nauto shader_setting = guik::ShaderSetting(color_mode, transformation)\n// Register the pair of drawable object and shader setting to the viewer\nviewer-&gt;update_drawable(\"drawable_name\", drawable, shader_setting);\n</code></pre>"},{"location":"shader/#transformation","title":"Transformation","text":"<p>guik::ShaderSetting accepts Eigen transformations (e.g., <code>Eigen::Matrix4f</code>, <code>Eigen::Isometry3f</code>, <code>Eigen::Affine3f</code> and their double counterparts) as the model transformation.</p> <p>It also has several utility methods to manipulate the model matrix. The utility methods applies a transformation on the right side of the original model transformation. <pre><code>// The model matrix becomes Identity() * Rotation(3.14rad, (1,0,0)) * Translation(1,0,0) * Scale(0.1)\nviewer-&gt;update_drawable(\"drawable_name\", drawable,\nguik::Rainbow().rotate(3.14f, {1.0f, 0.0f, 0.0f}).translate({1.0f, 0.0f, 0.0f}).scale(0.1f)\n);\n</code></pre></p>"},{"location":"shader/#coloring-schemes","title":"Coloring schemes","text":"<p>There are four coloring schemes in Iridescence, and they have corresponding utility classes that are derived from <code>guik::ShaderSetting</code>:</p> <ul> <li>RAINBOW (guik::Rainbow) scheme draws pixels with colors that encode the 3D position of each pixel (By default, it encodes the height (z) position of each pixel).</li> <li>FLAT_COLOR (guik::FlatColor) scheme draws pixels with a flat color.</li> <li>VERTEX_COLOR (guik::VertexColor) scheme draws pixels with interpolated colors of corresponding vertices.</li> <li>TEXTURE_COLOR (guik::TextureColor) scheme samples pixel colors from a texture.</li> </ul> <p> Left to right: Rainbow, FlatColor, VertexColor, TextureColor (transparent)</p> <pre><code>Eigen::Matrix4f transformation = Eigen::Matrix4f::Identity();\n// RAINBOW\nauto shader_setting = guik::Rainbow(transformation);\n// FLAT_COLOR\nEigen::Vector4f color(1.0f, 0.5f, 0.0f, 1.0f);\nauto shader_setting = guik::FlatColor(color, transformation);\n// There are several flat color utility classes correspond to primitive colors\n// guik::FlatRed() == guik::FlatColor({1.0f, 0.0f, 0.0f, 1.0f});\n// guik::FlatGreen() == guik::FlatColor({0.0f, 1.0f, 0.0f, 1.0f});\n// guik::FlatBlue() == guik::FlatColor({0.0f, 0.0f, 1.0f, 1.0f});\n// guik::FlatOrange() == guik::FlatColor({1.0f, 0.5f, 0.0f, 1.0f});\n// VERTEX_COLOR\nauto shader_setting = guik::VertexColor(transformation);\n// TEXTURE_COLOR with transparency\nauto shader_setting = guik::TextureColor(transformation).make_transparent();\n</code></pre> <p> Example of point clouds rendered using the rainbow coloring scheme</p>"}]}