"""
"""
from __future__ import annotations
import numpy
import pyridescence.glk
import typing
__all__: list[str] = ['Application', 'ArcBallCameraControl', 'AsyncLightViewer', 'AsyncLightViewerContext', 'CIRCLE', 'CameraControl', 'FPSCameraControl', 'FlatBlue', 'FlatColor', 'FlatGreen', 'FlatOrange', 'FlatRed', 'HoveredDrawings', 'LightViewer', 'LightViewerContext', 'METRIC', 'ModelControl', 'OrbitCameraControlXY', 'OrbitCameraControlXZ', 'PointScaleMode', 'PointShapeMode', 'ProjectionControl', 'RECTANGLE', 'Rainbow', 'RecentFiles', 'SCREENSPACE', 'ShaderSetting', 'TopDownCameraControl', 'VertexColor', 'anon', 'async_destroy', 'async_viewer', 'async_wait', 'destroy', 'viewer']
class Application:
    def close(self) -> None:
        ...
    def closed(self) -> bool:
        ...
    def disable_docking(self) -> None:
        ...
    def disable_vsync(self) -> None:
        ...
    def enable_docking(self) -> None:
        ...
    def enable_vsync(self) -> None:
        ...
    def framebuffer_size(self) -> numpy.ndarray[numpy.int32[2, 1]]:
        ...
    def fullscreen_window(self) -> None:
        ...
    def hide_window(self) -> None:
        ...
    def maximize_window(self) -> None:
        ...
    def ok(self) -> bool:
        ...
    def resize(self, arg0: numpy.ndarray[numpy.int32[2, 1]]) -> None:
        ...
    def set_title(self, arg0: str) -> None:
        ...
    def show_window(self) -> None:
        ...
    def spin(self) -> None:
        ...
    def spin_once(self) -> bool:
        ...
    def window_size(self) -> numpy.ndarray[numpy.int32[2, 1]]:
        ...
class ArcBallCameraControl(CameraControl):
    pass
class AsyncLightViewer(AsyncLightViewerContext):
    @staticmethod
    def destroy() -> None:
        ...
    @staticmethod
    def instance(size: numpy.ndarray[numpy.int32[2, 1]] = ..., background: bool = False, title: str = 'screen') -> LightViewer:
        ...
    @staticmethod
    def toggle_wait() -> None:
        ...
    @staticmethod
    def wait() -> None:
        ...
    @staticmethod
    def wait_until_click() -> None:
        ...
    def async_sub_viewer(self, arg0: str, arg1: tuple[int, int]) -> AsyncLightViewerContext:
        ...
    def clear_images(self) -> None:
        ...
    def fit_all_plots(self) -> None:
        ...
    def fit_plot(self, plot_name: str) -> None:
        ...
    def remove_image(self, arg0: str) -> None:
        ...
    def update_image(self, name: str, width: int, height: int, rgba_bytes: list[int], scale: float = -1.0, order: int = -1) -> None:
        ...
    def update_plot_histogram(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], x_bins: int = -2, y_bins: int = -2, x_range: numpy.ndarray[numpy.float64[2, 1]] = ..., y_range: numpy.ndarray[numpy.float64[2, 1]] = ..., histogram_flags: int = 0) -> None:
        ...
    def update_plot_line(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], line_flags: int = 0, max_num_data: int = 1048576) -> None:
        ...
    def update_plot_scatter(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], scatter_flats: int = 0) -> None:
        ...
class AsyncLightViewerContext:
    def append_text(self, arg0: str) -> None:
        ...
    def clear(self) -> None:
        ...
    def clear_drawables(self) -> None:
        ...
    def clear_text(self) -> None:
        ...
    def disable_xy_grid(self) -> None:
        ...
    def enable_xy_grid(self) -> None:
        ...
    def load_camera_settings(self, path: str) -> None:
        ...
    def lookat(self, pt: numpy.ndarray[numpy.float32[3, 1]]) -> None:
        ...
    def register_ui_callback(self, callback_name: str, callback: typing.Callable[[], None]) -> None:
        ...
    def remove_drawable(self, pattern: str, regex: bool = False) -> None:
        ...
    def remove_ui_callback(self, callback_name: str) -> None:
        ...
    def reset_center(self) -> None:
        ...
    def save_camera_settings(self, path: str) -> None:
        ...
    def save_color_buffer(self, path: str) -> None:
        ...
    def save_depth_buffer(self, path: str, real_scale: bool = True) -> None:
        ...
    def set_colormap(self, arg0: pyridescence.glk.COLORMAP) -> None:
        ...
    def set_draw_xy_grid(self, arg0: bool) -> None:
        ...
    def set_point_shape(self, point_size: float = 1.0, metric: bool = True, circle: bool = True) -> None:
        ...
    def update_cone(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_coord(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_cube(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_drawable_setting(self, name: str, setting: ShaderSetting) -> None:
        ...
    def update_frustum(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_icosahedron(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_normal_dists(self, arg0: str, arg1: list[numpy.ndarray[numpy.float32[3, 1]]], arg2: list[numpy.ndarray[numpy.float32[3, 3]]], arg3: float, arg4: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_normal_dists(self, arg0: str, arg1: list[numpy.ndarray[numpy.float32[4, 1]]], arg2: list[numpy.ndarray[numpy.float32[4, 4]]], arg3: float, arg4: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_points(self, arg0: str, arg1: numpy.ndarray[numpy.float32[m, n]], arg2: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_points(self, arg0: str, arg1: numpy.ndarray[numpy.float32[m, n]], arg2: numpy.ndarray[numpy.float32[m, n]], arg3: ShaderSetting) -> None:
        ...
    def update_sphere(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_thin_lines(self, name: str, vertices: numpy.ndarray[numpy.float32[m, n]], colors: numpy.ndarray[numpy.float32[m, n]] = ..., indices: list[int] = [], line_strip: bool = False, shader_setting: ShaderSetting = ...) -> None:
        ...
    def update_wire_cone(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_cube(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_frustum(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_icosahedron(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_sphere(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def use_arcball_camera_control(self, distance: float = 80.0, theta: float = 0.0, phi: float = -1.0471975511965976) -> None:
        ...
    def use_fps_camera_control(self, fovy_deg: float = 60.0) -> None:
        ...
    def use_orbit_camera_control(self, distance: float = 80.0, theta: float = 0.0, phi: float = -1.0471975511965976) -> None:
        ...
    def use_orbit_camera_control_xz(self, distance: float = 80.0, theta: float = 0.0, phi: float = 0.0) -> None:
        ...
    def use_topdown_camera_control(self, distance: float = 80.0, theta: float = 0.0) -> None:
        ...
class CameraControl:
    def lookat(self, arg0: numpy.ndarray[numpy.float32[3, 1]]) -> None:
        ...
    def reset_center(self) -> None:
        ...
    def view_matrix(self) -> numpy.ndarray[numpy.float32[4, 4]]:
        ...
class FPSCameraControl(CameraControl):
    def set_depth_range(self, arg0: numpy.ndarray[numpy.float32[2, 1]]) -> None:
        ...
    def set_fovy(self, arg0: float) -> None:
        ...
    def set_mouse_senstivity(self, arg0: float, arg1: float) -> None:
        ...
    def set_pose(self, arg0: numpy.ndarray[numpy.float32[3, 1]], arg1: float, arg2: float) -> None:
        ...
    def set_translation_speed(self, arg0: float) -> None:
        ...
class FlatBlue(FlatColor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class FlatColor(ShaderSetting):
    @typing.overload
    def __init__(self, r: float, g: float, b: float, a: float) -> None:
        ...
    @typing.overload
    def __init__(self, r: float, g: float, b: float, a: float, model_matrix: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, r: float, g: float, b: float, a: float, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class FlatGreen(FlatColor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class FlatOrange(FlatColor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class FlatRed(FlatColor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class HoveredDrawings:
    def __init__(self, context: ... = None) -> None:
        ...
    def add_circle(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, radius: float = 10.0, num_segments: int = 32, thickness: float = 1.0) -> int:
        ...
    def add_circle_on(self, drawable_name: str, color: int = 4294967295, radius: float = 10.0, num_segments: int = 32, thickness: float = 1.0) -> int:
        ...
    def add_cross(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, size: float = 7.070000171661377, thickness: float = 1.0) -> int:
        ...
    def add_cross_on(self, drawable_name: str, color: int = 4294967295, size: float = 7.070000171661377, thickness: float = 1.0) -> int:
        ...
    def add_filled_rect(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_filled_rect_on(self, drawable_name: str, color: int = 4294967295, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_filled_triangle(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, height: float = 20.0, upsidedown: bool = True, centering: bool = False) -> int:
        ...
    def add_filled_triangle_on(self, drawable_name: str, color: int = 4294967295, height: float = 20.0, upsidedown: bool = True, centering: bool = False) -> int:
        ...
    def add_image(self, pt: numpy.ndarray[numpy.float32[3, 1]], texture: pyridescence.glk.Texture, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ..., bg_color: int = 0, border_color: int = 0, border_thickness: float = 1.0) -> int:
        ...
    def add_image_on(self, drawable_name: str, texture: pyridescence.glk.Texture, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ..., bg_color: int = 0, border_color: int = 0, border_thickness: float = 1.0) -> int:
        ...
    def add_rect(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_rect_on(self, drawable: str, color: int = 4294967295, size: numpy.ndarray[numpy.float32[2, 1]] = ..., offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_text(self, pt: numpy.ndarray[numpy.float32[3, 1]], text: str, fg_color: int = 4294967295, bg_color: int = 2147483648, offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_text_on(self, drawable_name: str, text: str, fg_color: int = 4294967295, bg_color: int = 2147483648, offset: numpy.ndarray[numpy.float32[2, 1]] = ...) -> int:
        ...
    def add_triangle(self, pt: numpy.ndarray[numpy.float32[3, 1]], color: int = 4294967295, height: float = 20.0, thickness: float = 1.0, upsidedown: bool = True, centering: bool = False) -> int:
        ...
    def add_triangle_on(self, drawable: str, color: int = 4294967295, height: float = 20.0, thickness: float = 1.0, upsidedown: bool = True, centering: bool = False) -> int:
        ...
    def clear(self) -> None:
        ...
    def create_callback(self) -> typing.Callable[[], None]:
        ...
    def remove_drawing(self, drawing_id: int) -> None:
        ...
class LightViewer(Application, LightViewerContext):
    @staticmethod
    def instance(size: numpy.ndarray[numpy.int32[2, 1]] = ..., background: bool = False, title: str = 'screen') -> LightViewer:
        ...
    def clear_images(self) -> None:
        ...
    def fit_all_plots(self) -> None:
        ...
    def fit_plot(self, plot_name: str) -> None:
        ...
    def remove_image(self, arg0: str) -> None:
        ...
    def spin_until_click(self) -> bool:
        ...
    def sub_viewer(self, name: str, size: tuple[int, int] = (-1, -1)) -> LightViewerContext:
        ...
    def toggle_spin_once(self) -> bool:
        ...
    def update_image(self, name: str, image: pyridescence.glk.Texture, scale: float = -1.0, order: int = -1) -> None:
        ...
    def update_plot_histogram(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], x_bins: int = -2, y_bins: int = -2, x_range: numpy.ndarray[numpy.float64[2, 1]] = ..., y_range: numpy.ndarray[numpy.float64[2, 1]] = ..., histogram_flags: int = 0) -> None:
        ...
    def update_plot_line(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], line_flags: int = 0, max_num_data: int = 1048576) -> None:
        ...
    def update_plot_scatter(self, plot_name: str, label: str, xs: list[float], ys: list[float] = [], scatter_flats: int = 0) -> None:
        ...
class LightViewerContext:
    def append_text(self, arg0: str) -> None:
        ...
    def clear(self) -> None:
        ...
    def clear_drawable_filters(self) -> None:
        ...
    def clear_drawables(self) -> None:
        ...
    def clear_partial_rendering(self) -> None:
        ...
    def clear_text(self) -> None:
        ...
    def color_buffer(self) -> pyridescence.glk.Texture:
        ...
    def depth_buffer(self) -> pyridescence.glk.Texture:
        ...
    def disable_partial_rendering(self) -> None:
        ...
    def disable_xy_grid(self) -> None:
        ...
    def enable_info_buffer(self) -> None:
        ...
    def enable_normal_buffer(self) -> None:
        ...
    def enable_partial_rendering(self, clear_thresh: float = 1e-06) -> None:
        ...
    def enable_xy_grid(self) -> None:
        ...
    def find_drawable(self, arg0: str) -> tuple[ShaderSetting, pyridescence.glk.Drawable]:
        ...
    def get_camera_control(self) -> CameraControl:
        ...
    def get_drawables(self) -> dict[str, tuple[ShaderSetting, pyridescence.glk.Drawable]]:
        ...
    def get_projection_control(self) -> ProjectionControl:
        ...
    def get_screen_effect(self) -> pyridescence.glk.ScreenEffect:
        ...
    def hide(self) -> None:
        ...
    def info_buffer(self) -> pyridescence.glk.Texture:
        ...
    def load_camera_settings(self, path: str) -> bool:
        ...
    def lookat(self, pt: numpy.ndarray[numpy.float32[3, 1]]) -> None:
        ...
    def normal_buffer(self) -> pyridescence.glk.Texture:
        ...
    def pick_depth(self, p: numpy.ndarray[numpy.int32[2, 1]], window: int = 2) -> float:
        ...
    def pick_info(self, p: numpy.ndarray[numpy.int32[2, 1]], window: int = 2) -> numpy.ndarray[numpy.int32[4, 1]]:
        ...
    def register_drawable_filter(self, arg0: str, arg1: typing.Callable[[str], bool]) -> None:
        ...
    def register_ui_callback(self, callback_name: str, callback: typing.Callable[[], None]) -> None:
        ...
    def remove_drawable(self, pattern: str, regex: bool = False) -> None:
        ...
    def remove_drawable_filter(self, arg0: str) -> None:
        ...
    def remove_ui_callback(self, callback_name: str) -> None:
        ...
    def reset_center(self) -> None:
        ...
    def save_camera_settings(self, path: str) -> bool:
        ...
    def save_color_buffer(self, path: str) -> bool:
        ...
    def save_depth_buffer(self, path: str, real_scale: bool = True) -> bool:
        ...
    def set_bg_texture(self, arg0: pyridescence.glk.Texture) -> None:
        ...
    def set_camera_control(self, arg0: CameraControl) -> None:
        ...
    def set_clear_color(self, arg0: numpy.ndarray[numpy.float32[4, 1]]) -> None:
        ...
    def set_colormap(self, arg0: pyridescence.glk.COLORMAP) -> None:
        ...
    def set_draw_xy_grid(self, arg0: bool) -> None:
        ...
    def set_point_shape(self, point_size: float = 1.0, metric: bool = True, circle: bool = True) -> None:
        ...
    def set_pos(self, pos: numpy.ndarray[numpy.int32[2, 1]], cond: int = 4, flags: int = 0) -> None:
        ...
    def set_projection_control(self, arg0: ProjectionControl) -> None:
        ...
    def set_screen_effect(self, arg0: pyridescence.glk.ScreenEffect) -> None:
        ...
    def set_size(self, arg0: numpy.ndarray[numpy.int32[2, 1]]) -> None:
        ...
    def shader_setting(self) -> ShaderSetting:
        ...
    def show(self) -> None:
        ...
    def unproject(self, p: numpy.ndarray[numpy.int32[2, 1]], depth: float) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
    def update_cone(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_coord(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_cube(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_drawable(self, arg0: str, arg1: pyridescence.glk.Drawable, arg2: ShaderSetting) -> None:
        ...
    def update_frustum(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_icosahedron(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_normal_dists(self, arg0: str, arg1: list[numpy.ndarray[numpy.float32[3, 1]]], arg2: list[numpy.ndarray[numpy.float32[3, 3]]], arg3: float, arg4: ShaderSetting) -> None:
        ...
    @typing.overload
    def update_normal_dists(self, arg0: str, arg1: list[numpy.ndarray[numpy.float32[4, 1]]], arg2: list[numpy.ndarray[numpy.float32[4, 4]]], arg3: float, arg4: ShaderSetting) -> None:
        ...
    def update_points(self, arg0: str, arg1: numpy.ndarray[numpy.float32[m, n]], arg2: ShaderSetting) -> pyridescence.glk.PointCloudBuffer:
        ...
    def update_sphere(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_thin_lines(self, name: str, vertices: numpy.ndarray[numpy.float32[m, n]], colors: numpy.ndarray[numpy.float32[m, n]] = ..., indices: list[int] = [], line_strip: bool = False, shader_setting: ShaderSetting = ...) -> pyridescence.glk.ThinLines:
        ...
    def update_wire_cone(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_cube(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_frustum(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_icosahedron(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def update_wire_sphere(self, arg0: str, arg1: ShaderSetting) -> None:
        ...
    def use_arcball_camera_control(self, distance: float = 80.0, theta: float = 0.0, phi: float = -1.0471975511965976) -> ArcBallCameraControl:
        ...
    @typing.overload
    def use_fps_camera_control(self, fovy_deg: float = 60.0) -> FPSCameraControl:
        ...
    @typing.overload
    def use_fps_camera_control(self, fovy_deg: float = 60.0) -> FPSCameraControl:
        ...
    def use_orbit_camera_control(self, distance: float = 80.0, theta: float = 0.0, phi: float = -1.0471975511965976) -> OrbitCameraControlXY:
        ...
    def use_orbit_camera_control_xz(self, distance: float = 80.0, theta: float = 0.0, phi: float = 0.0) -> OrbitCameraControlXZ:
        ...
    def use_topdown_camera_control(self, distance: float = 80.0, theta: float = 0.0) -> TopDownCameraControl:
        ...
class ModelControl:
    def __init__(self, label: str = 'model_control', model_matrix: numpy.ndarray[numpy.float32[4, 4]] = ...) -> None:
        ...
    def disable_gizmo(self) -> None:
        ...
    def draw_gizmo(self) -> None:
        ...
    def draw_gizmo_ui(self) -> None:
        ...
    def draw_ui(self) -> None:
        ...
    def enable_gizmo(self) -> None:
        ...
    def model_matrix(self) -> numpy.ndarray[numpy.float32[4, 4]]:
        ...
    def set_gizmo_clip_scale(self, arg0: float) -> None:
        ...
    def set_gizmo_enabled(self, arg0: bool) -> None:
        ...
    def set_gizmo_mode(self, arg0: int) -> None:
        ...
    def set_gizmo_operation(self, arg0: str) -> None:
        ...
    def set_model_matrix(self, model_matrix: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
class OrbitCameraControlXY(CameraControl):
    pass
class OrbitCameraControlXZ(CameraControl):
    pass
class PointScaleMode:
    """
    Members:
    
      SCREENSPACE
    
      METRIC
    """
    METRIC: typing.ClassVar[PointScaleMode]  # value = <PointScaleMode.METRIC: 1>
    SCREENSPACE: typing.ClassVar[PointScaleMode]  # value = <PointScaleMode.SCREENSPACE: 0>
    __members__: typing.ClassVar[dict[str, PointScaleMode]]  # value = {'SCREENSPACE': <PointScaleMode.SCREENSPACE: 0>, 'METRIC': <PointScaleMode.METRIC: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class PointShapeMode:
    """
    Members:
    
      RECTANGLE
    
      CIRCLE
    """
    CIRCLE: typing.ClassVar[PointShapeMode]  # value = <PointShapeMode.CIRCLE: 1>
    RECTANGLE: typing.ClassVar[PointShapeMode]  # value = <PointShapeMode.RECTANGLE: 0>
    __members__: typing.ClassVar[dict[str, PointShapeMode]]  # value = {'RECTANGLE': <PointShapeMode.RECTANGLE: 0>, 'CIRCLE': <PointShapeMode.CIRCLE: 1>}
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __repr__(self) -> str:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class ProjectionControl:
    pass
class Rainbow(ShaderSetting):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
class RecentFiles:
    def __init__(self, arg0: str) -> None:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def filename(self, arg0: int) -> str:
        ...
    def fullpath(self, arg0: int) -> str:
        ...
    def most_recent(self) -> str:
        ...
    def push(self, arg0: str) -> None:
        ...
    def push_all(self, arg0: list[str]) -> None:
        ...
    def size(self) -> int:
        ...
class ShaderSetting:
    @typing.overload
    def add(self, arg0: str, arg1: float) -> ShaderSetting:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: numpy.ndarray[numpy.float32[2, 1]]) -> ShaderSetting:
        ...
    @typing.overload
    def add(self, arg0: str, arg1: numpy.ndarray[numpy.float32[4, 4]]) -> ShaderSetting:
        ...
    def addi(self, arg0: str, arg1: numpy.ndarray[numpy.int32[4, 1]]) -> ShaderSetting:
        ...
    def color_mode(self) -> int:
        ...
    def dynamic_object(self) -> ShaderSetting:
        ...
    def make_transparent(self) -> ShaderSetting:
        ...
    def material_color(self) -> numpy.ndarray[numpy.float32[4, 1]]:
        ...
    def model_matrix(self) -> numpy.ndarray[numpy.float32[4, 4]]:
        ...
    def point_scale(self) -> float:
        ...
    def remove_model_matrix(self) -> ShaderSetting:
        ...
    @typing.overload
    def rotate(self, angle: float, axis: numpy.ndarray[numpy.float32[3, 1]]) -> ShaderSetting:
        ...
    @typing.overload
    def rotate(self, rotation: numpy.ndarray[numpy.float32[3, 3]]) -> ShaderSetting:
        ...
    def rotation(self) -> numpy.ndarray[numpy.float32[3, 3]]:
        ...
    @typing.overload
    def scale(self, scale: float) -> ShaderSetting:
        ...
    @typing.overload
    def scale(self, scale: numpy.ndarray[numpy.float32[3, 1]]) -> ShaderSetting:
        ...
    def set_alpha(self, arg0: float) -> ShaderSetting:
        ...
    @typing.overload
    def set_color(self, r: float, g: float, b: float, a: float = 1.0) -> ShaderSetting:
        ...
    @typing.overload
    def set_color(self, color: numpy.ndarray[numpy.float32[4, 1]]) -> ShaderSetting:
        ...
    def set_color_mode(self, color_mode: int) -> ShaderSetting:
        ...
    def set_model_matrix(self, model_matrix: numpy.ndarray[numpy.float32[4, 4]]) -> ShaderSetting:
        ...
    def set_point_scale(self, scale: float) -> ShaderSetting:
        ...
    def set_point_scale_metric(self) -> ShaderSetting:
        ...
    def set_point_scale_mode(self, mode: PointScaleMode) -> ShaderSetting:
        ...
    def set_point_scale_screenspace(self) -> ShaderSetting:
        ...
    def set_point_shape(self, point_size: float, metric: bool, circle: bool) -> ShaderSetting:
        ...
    def set_point_shape_circle(self) -> ShaderSetting:
        ...
    def set_point_shape_mode(self, mode: PointShapeMode) -> ShaderSetting:
        ...
    def set_point_shape_rectangle(self) -> ShaderSetting:
        ...
    def set_point_size(self, size: float) -> ShaderSetting:
        ...
    def set_point_size_offset(self, offset: float) -> ShaderSetting:
        ...
    def static_object(self) -> ShaderSetting:
        ...
    def transform(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> ShaderSetting:
        ...
    @typing.overload
    def translate(self, x: float, y: float, z: float) -> ShaderSetting:
        ...
    @typing.overload
    def translate(self, translation: numpy.ndarray[numpy.float32[3, 1]]) -> ShaderSetting:
        ...
    def translation(self) -> numpy.ndarray[numpy.float32[3, 1]]:
        ...
class TopDownCameraControl(CameraControl):
    pass
class VertexColor(ShaderSetting):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: numpy.ndarray[numpy.float32[4, 4]]) -> None:
        ...
    @typing.overload
    def __init__(self, scale: float = 1.0, trans: numpy.ndarray[numpy.float32[3, 1]] = ..., rot: numpy.ndarray[numpy.float32[3, 3]] = ...) -> None:
        ...
def anon() -> str:
    ...
def async_destroy() -> None:
    ...
def async_viewer(size: numpy.ndarray[numpy.int32[2, 1]] = ..., background: bool = False, title: str = 'screen') -> AsyncLightViewer:
    ...
def async_wait() -> None:
    ...
def destroy() -> None:
    ...
def viewer(size: numpy.ndarray[numpy.int32[2, 1]] = ..., background: bool = False, title: str = 'screen') -> LightViewer:
    ...
CIRCLE: PointShapeMode  # value = <PointShapeMode.CIRCLE: 1>
METRIC: PointScaleMode  # value = <PointScaleMode.METRIC: 1>
RECTANGLE: PointShapeMode  # value = <PointShapeMode.RECTANGLE: 0>
SCREENSPACE: PointScaleMode  # value = <PointScaleMode.SCREENSPACE: 0>
